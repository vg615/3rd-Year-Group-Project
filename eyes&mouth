from imutils.video import VideoStream
from imutils import face_utils
import numpy as np
import imutils
import time
import dlib
import cv2

def euclidean_dist(ptA, ptB):
	# compute and return the euclidean distance between the two
	# points
	return np.linalg.norm(ptA - ptB)

def eye_aspect_ratio(eye):
	# compute the euclidean distances between the two sets of
	# vertical eye landmarks (x, y)-coordinates
	A = euclidean_dist(eye[1], eye[5])
	B = euclidean_dist(eye[2], eye[4])

	# compute the euclidean distance between the horizontal
	# eye landmark (x, y)-coordinates
	C = euclidean_dist(eye[0], eye[3])

	# compute the eye aspect ratio
	ear = (A + B) / (2.0 * C)

	# return the eye aspect ratio
	return ear
    
def mouth_aspect_ratio(mouth):
    
    A = euclidean_dist(mouth[2], mouth[10])
    B = euclidean_dist(mouth[4], mouth[8])
    
    C = euclidean_dist(mouth[0], mouth[6])
    
    mar = (A + B)/ (2.0 * C)
    
    return mar
    


# define two constants, one for the eye aspect ratio to indicate
# blink and then a second constant for the number of consecutive
# frames the eye must be below the threshold for to set off the
# alarm
EYE_AR_THRESH = 0.25
EYE_AR_CONSEC_FRAMES = 4

# initialize the frame counter as well as a boolean used to
# indicate if the alarm is going off
COUNTER = 0
ALARM_ON = False


detector = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
predictor = dlib.shape_predictor('shape_predictor_68_face_landmarks.dat')



# grab the indexes of the facial landmarks for the left and
# right eye, respectively
(lStart, lEnd) = face_utils.FACIAL_LANDMARKS_IDXS["left_eye"]
(rStart, rEnd) = face_utils.FACIAL_LANDMARKS_IDXS["right_eye"]
(mStart, mEnd) = face_utils.FACIAL_LANDMARKS_IDXS["mouth"]


vs = VideoStream(usePiCamera=True).start()
time.sleep(1.0)

while True:
    frame = vs.read()
    frame = imutils.resize(frame, width=450)
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    #detect faces in the grayscale frame
    rects = detector.detectMultiScale(gray, scaleFactor=1.1, 
		minNeighbors=5, minSize=(30, 30),
		flags=cv2.CASCADE_SCALE_IMAGE)
    # loop over the face detections
    for (x, y, w, h) in rects:
	    # construct a dlib rectangle object from the Haar cascade
	    # bounding box
	    rect = dlib.rectangle(int(x), int(y), int(x + w),
		    int(y + h))

	    # determine the facial landmarks for the face region, then
	    # convert the facial landmark (x, y)-coordinates to a NumPy
	    # array
	    shape = predictor(gray, rect)
	    shape = face_utils.shape_to_np(shape)
	    
	    # extract the left and right eye coordinates, then use the
	    # coordinates to compute the eye aspect ratio for both eyes
	    leftEye = shape[lStart:lEnd]
	    rightEye = shape[rStart:rEnd]
	    mouth = shape[mStart:mEnd]
	    leftEAR = eye_aspect_ratio(leftEye)
	    rightEAR = eye_aspect_ratio(rightEye)
	    mouthMAR = mouth_aspect_ratio(mouth)
    
	    # average the eye aspect ratio together for both eyes
	    ear = (leftEAR + rightEAR) / 2.0

	    # compute the convex hull for the left and right eye, then
	    # visualize each of the eyes
	    leftEyeHull = cv2.convexHull(leftEye)
	    rightEyeHull = cv2.convexHull(rightEye)
	    mouthHull = cv2.convexHull(mouth)
	    cv2.drawContours(frame, [leftEyeHull], -1, (0, 255, 0), 1)
	    cv2.drawContours(frame, [rightEyeHull], -1, (0, 255, 0), 1)
	    cv2.drawContours(frame, [mouthHull], -1, (0, 255, 0), 1)
	    
	    # check to see if the eye aspect ratio is below the blink
	    # threshold, and if so, increment the blink frame counter
	    if ear < EYE_AR_THRESH:
		    COUNTER += 1
		    # if the eyes were closed for a sufficient number of
		    # frames, then sound the alarm
		    if COUNTER >= EYE_AR_CONSEC_FRAMES:
			    # if the alarm is not on, turn it on
			    if not ALARM_ON:
				    ALARM_ON = True
				    # draw an alarm on the frame
                            cv2.putText(frame, "DROWSINESS ALERT!", (10, 30),
				    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
	    
            # otherwise, the eye aspect ratio is not below the blink
	    # threshold, so reset the counter and alarm
	    else:
		COUNTER = 0
		ALARM_ON = False	    
	    
	    # draw the computed eye aspect ratio on the frame to help
	    # with debugging and setting the correct eye aspect ratio
	    # thresholds and frame counters
	    #cv2.putText(frame, "EAR: {:.3f}".format(ear), (300, 30),
			#cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
	    cv2.putText(frame, "MAR: {:.3f}".format(mouthMAR), (300, 50),
			cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)


    cv2.imshow("Frame", frame)
    key = cv2.waitKey(1) & 0xFF
    if key == ord("q"):
        break

cv2.destroyAllWindows()
vs.stop()
