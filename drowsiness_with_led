from imutils.video import VideoStream
from imutils import face_utils
from gpiozero import TrafficHat
import RPi.GPIO
import numpy as np
import imutils
import time
import dlib
import cv2
from threading import Thread
from threading import Lock


def yawn_once():
    th.lights.amber.blink(0.5,0.5,20,False)
        

def yawn_more_than_once():
    th.lights.red.blink(0.5,0.5,20,False)

    
def fall_asleep():
    th.buzzer.blink(0.1, 0.1, 5, background=True)
    


th = TrafficHat()
count = 0
yawns = 0
test_yawn = 0

while(count < 3):
    th.lights.red.on()
    time.sleep(0.3)
    th.lights.red.off()
    th.lights.amber.on()
    time.sleep(0.3)
    th.lights.amber.off()
    th.lights.green.on()
    time.sleep(0.3)
    th.lights.green.off()
    count = count + 1
    
th.lights.green.on()

def euclidean_dist(ptA, ptB):
	# compute and return the euclidean distance between the two
	# points
	return np.linalg.norm(ptA - ptB)

def eye_aspect_ratio(eye):
	# compute the euclidean distances between the two sets of
	# vertical eye landmarks (x, y)-coordinates
	A = euclidean_dist(eye[1], eye[5])
	B = euclidean_dist(eye[2], eye[4])

	# compute the euclidean distance between the horizontal
	# eye landmark (x, y)-coordinates
	C = euclidean_dist(eye[0], eye[3])

	# compute the eye aspect ratio
	ear = (A + B) / (2.0 * C)

	# return the eye aspect ratio
	return ear
    
def mouth_aspect_ratio(mouth):
    
    A = euclidean_dist(mouth[2], mouth[10])
    B = euclidean_dist(mouth[4], mouth[8])
    
    C = euclidean_dist(mouth[0], mouth[6])
    
    mar = (A + B)/ (2.0 * C)
    
    return mar
    


# define two constants, one for the eye aspect ratio to indicate
# blink and then a second constant for the number of consecutive
# frames the eye must be below the threshold for to set off the
# alarm
EYE_AR_THRESH = 0.23
EYE_AR_CONSEC_FRAMES = 3

MOUTH_AR_THRESH = 0.65
MOUTH_AR_CONSEC_FRAMES = 3

# initialize the frame counter as well as a boolean used to
# indicate if the alarm is going off
COUNTER_EYE = 0
COUNTER_MOUTH = 0


detector = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
predictor = dlib.shape_predictor('shape_predictor_68_face_landmarks.dat')


# grab the indexes of the facial landmarks for the left and
# right eye, respectively
(lStart, lEnd) = face_utils.FACIAL_LANDMARKS_IDXS["left_eye"]
(rStart, rEnd) = face_utils.FACIAL_LANDMARKS_IDXS["right_eye"]
(mStart, mEnd) = face_utils.FACIAL_LANDMARKS_IDXS["mouth"]


vs = VideoStream(usePiCamera=True).start()
time.sleep(1.0)

while True:
    frame = vs.read()
    frame = imutils.resize(frame, width=450)
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    #detect faces in the grayscale frame
    rects = detector.detectMultiScale(gray, scaleFactor=1.1, 
		minNeighbors=5, minSize=(30, 30),
		flags=cv2.CASCADE_SCALE_IMAGE)
    # loop over the face detections
    for (x, y, w, h) in rects:
	    # construct a dlib rectangle object from the Haar cascade
	    # bounding box
	    rect = dlib.rectangle(int(x), int(y), int(x + w),
		    int(y + h))

	    # determine the facial landmarks for the face region, then
	    # convert the facial landmark (x, y)-coordinates to a NumPy
	    # array
	    shape = predictor(gray, rect)
	    shape = face_utils.shape_to_np(shape)
	    
	    # extract the left and right eye coordinates, then use the
	    # coordinates to compute the eye aspect ratio for both eyes
	    leftEye = shape[lStart:lEnd]
	    rightEye = shape[rStart:rEnd]
	    mouth = shape[mStart:mEnd]
	    leftEAR = eye_aspect_ratio(leftEye)
	    rightEAR = eye_aspect_ratio(rightEye)
	    mar = mouth_aspect_ratio(mouth)
    
	    # average the eye aspect ratio together for both eyes
	    ear = (leftEAR + rightEAR) / 2.0

	    
	    # check to see if the eye aspect ratio is below the blink
	    # threshold, and if so, increment the blink frame counter
	    if ear < EYE_AR_THRESH:
		    COUNTER_EYE += 1
		    # if the eyes were closed for a sufficient number of
		    # frames, then sound the alarm
		    if COUNTER_EYE >= EYE_AR_CONSEC_FRAMES:
                        t_drowsy = Thread(target = fall_asleep)
                        t_drowsy.deamon = True
                        t_drowsy.start()
			    
	    
            # otherwise, the eye aspect ratio is not below the blink
	    # threshold, so reset the counter and alarm
	    else:
		COUNTER_EYE = 0
		
	    if mar > MOUTH_AR_THRESH:
                COUNTER_MOUTH += 1
                if COUNTER_MOUTH > MOUTH_AR_CONSEC_FRAMES:
                    if test_yawn == 0:
                        yawns += 1
                        test_yawn = 1
                    
                    if yawns == 1:    
                        t1 = Thread(target = yawn_once)
                        t1.deamon = True
                        t1.start()
                    else:
                        t2 = Thread(target = yawn_more_than_once)
                        t2.deamon = True
                        t2.start()

            else:
                COUNTER_MOUTH = 0
                test_yawn = 0
